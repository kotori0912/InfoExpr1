//====================================================================
//  情報環境実験I 第9回
//  15T207 伊藤 拓海
//====================================================================

//====================================================================
//  ヘッダ情報
//====================================================================

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include "AlgoSortProc.h"
#include "RandSeq.h"

//--------------------------------------------------------------------
//  マクロ定義
//--------------------------------------------------------------------

#define  TRY  1000
#define  DEG   1024


//====================================================================
//  メイン関数
//====================================================================

int main(int argv, char *argc[]) 
{
  //----  宣言
  // int sw = 0;        // 算法の種別
  char *str;         // 算法メッセージ
  int ct_cmp = 0;    // 比較回数
  int cmp = 0;    // 比較回数の合計
  int ct_swp = 0;    // 交換回数
  int swp = 0;   // 交換回数の合計
  int m;           // 試行数
  int n;           // データ数
  Data arr[DEG];    // 乱順列
  int k;           // 反復変数
  double p;        // 確率指定
  int c;           // 回数指定
  clock_t start, end;    // 時間測定
  double t0 = 0.0;
  struct timeval tv;
  
  //----  入力
  m = TRY;
  n = DEG;
  p = atof(argc[1]);
  // scanf("%d", &c);

  //----  全体の反復
  while ( m-- > 0 ) {
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec + tv.tv_usec);
    //--  配列の初期化
    for ( k = 0; k < n; k++ ) {
      arr[k] = k;
    }
    //--  乱順列
    prand(arr, n, p);    // 確率指定
    //----  整列算法
    
    start = clock();
    comb_sort(arr, n, &ct_cmp, &ct_swp);
    end = clock();
    
    cmp += ct_cmp;
    swp += ct_swp;
    ct_cmp = 0;
    ct_swp = 0;
    t0 += (end - start + 0.0) / CLOCKS_PER_SEC;
  }

  //----  整列結果の出力
  //puts("");
  //printf("%s  比較 %3d回  交換 %3d回\n", str, ct_cmp, ct_swp);
  printf("%d,%d,", cmp/TRY, swp/TRY);
  printf("%lf\n", t0/TRY);
  return 0;
}

//====================================================================
//  コームソート
//====================================================================

void comb_sort(int arr[], int n, int *ct_c, int *ct_s) 
{
  double cnt = 1.3;    // 間隔列の収縮係数
  int gap = n;                // 間隔の最大値
  int k;
  Bool flag = FALSE;           // 交換の有無

  //----  コームソートの本体
  while ( gap > 1 || flag == TRUE ) {
    //--  
    flag = FALSE;    // 交換無に初期化
    gap /= cnt;      // 間隔の更新
    //--  間隔の調整
    if ( gap == 0 ) { gap = 1; }                  // 間隔1は必須
    if ( gap == 9 || gap == 10 ) { gap = 11; }    // 経験的な調整
    //--  コームソートの各ラン(指定間隔での単純交換法)
    for ( k = 0; k < n - gap; k++ ) {
      if ( ! arr_ord_ct(arr, k, k+gap, ct_c) ) { 
        arr_swap_ct(arr, k, k+gap, ct_s); 
        flag = TRUE;
      } 
    }
    //proc_view(arr, n, *ct_c, *ct_s);    // 整列過程の表示
  }
}
//====================================================================
//  補助関数
//====================================================================

//--------------------------------------------------------------------
//  配列の要素の比較
//--------------------------------------------------------------------

Bool arr_ord(Data arr[], int p1, int p2) 
{
  if ( arr[p1] <= arr[p2] ) { return TRUE; } else { return FALSE; }
}

Bool arr_ord_ct(Data arr[], int p1, int p2, int *ct) 
{
  (*ct)++;    // 比較回数のカウント
  if ( arr[p1] <= arr[p2] ) { return TRUE; } else { return FALSE; }
}
//--------------------------------------------------------------------
//  配列の要素の交換
//--------------------------------------------------------------------

void arr_swap(Data arr[], int p1, int p2) 
{
  Data tmp;
  tmp = arr[p1]; arr[p1] = arr[p2]; arr[p2] = tmp;
}

void arr_swap_ct(Data arr[], int p1, int p2, int *ct) 
{
  Data tmp;
  (*ct)++;     // 交換回数のカウント
  tmp = arr[p1]; arr[p1] = arr[p2]; arr[p2] = tmp;
}

//--------------------------------------------------------------------
//  配列の要素の挿入
//--------------------------------------------------------------------

void arr_ins(Data arr[], int p, int m) {              // m-p回の交換に相当
  Data tmp = arr[m];                                  // データを退避
  int k;
  for ( k = m; k > p; k-- ) { arr[k] = arr[k-1]; }    // データを後方移動
  arr[p] = tmp;                                       // データを挿入
}


//====================================================================
//  配列の入出力
//====================================================================

//--------------------------------------------------------------------
//  配列への入力
//--------------------------------------------------------------------

void arr_input(Data arr[], int n) 
{
  int k;
  for ( k = 0; k < n; k++ ) { scanf("%2d", &arr[k]); }
}

//--------------------------------------------------------------------
//  配列からの出力
//--------------------------------------------------------------------

void arr_output(Data arr[], int n) 
{
  int k;
  for ( k = 0; k < n; k++ ) { printf("%2d ", arr[k]); }
}
//--------------------------------------------------------------------
//  0以上1未満の実数値乱数
//--------------------------------------------------------------------

double frand(void) 
{
  return rand() / (RAND_MAX +1.0);    // +1.0 で実数化
}

//--------------------------------------------------------------------
//  n未満の自然数の整数値乱数
//--------------------------------------------------------------------

int irand(int n) 
{ 
  return (int) (n * frand());    // int型への型変換
}

//====================================================================
//  半乱順列の生成
//====================================================================

//--------------------------------------------------------------------
//  回数指定による半乱順列
//--------------------------------------------------------------------

void crand(Data seq[], int n, int c) 
{
  int p1, p2;
  while ( c-- > 0 ) {                // c回だけ交換
    p1 = irand(n); p2 = irand(n); 
    arr_swap(seq, p1, p2);  
  }
}

//--------------------------------------------------------------------
//  回数指定による半乱順列(必ず交換)
//--------------------------------------------------------------------

void crand2(Data seq[], int n, int c) 
{
  int p1, p2;
  while ( c-- > 0 ) {
    p1 = irand(n); 
    do { p2 = irand(n); } while ( p1 == p2 );    // p2はp1と異なる値を選ぶ
    arr_swap(seq, p1, p2);    
  }
}

//--------------------------------------------------------------------
//  確率指定による半乱順列
//--------------------------------------------------------------------

void prand(Data seq[], int n, double p) 
{
  int k, t;
  for ( k = 1; k < n; k++ ) {    
    if ( frand() < p ) {         // 確率p未満のときのみ
      t = irand(k+1);            // k以下の整乱数
      arr_swap(seq, t, k);       // 要素の交換
    }
  }
}

