//====================================================================
//  情報環境実験I 第9回
//  15T207 伊藤 拓海
//====================================================================

//====================================================================
//  ヘッダ情報
//====================================================================

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include "AlgoSortProc.h"
#include "RandSeq.h"

//--------------------------------------------------------------------
//  マクロ定義
//--------------------------------------------------------------------

#define  TRY  1000
#define  DEG   1024


//====================================================================
//  メイン関数
//====================================================================

int main(int argv, char *argc[]) 
{
  //----  宣言
  int sw = 0;        // 算法の種別
  int ct_cmp = 0;    // 比較回数
  int cmp = 0;   // 比較回数の合計
  int ct_swp = 0;    // 交換回数
  int swp = 0;    // 交換回数の合計 
  int m;           // 試行数
  int n;           // データ数
  int arr[DEG];    // 乱順列
  int k;           // 反復変数
  double p;        // 確率指定
  int c;           // 回数指定
  clock_t start, end;    // 時間測定
  double t0 = 0.0;
  struct timeval tv;
  
  //----  算法の指定
  if ( argv == 3 ) { sw = atoi(argc[1]); }
  if ( sw < 4 || sw > 8 ) {
    puts("実行時引数の不正"); 
    puts("6: クイック法  7: マージ法  8: ヒープ法"); 
    return 0;
  }
  
  //----  入力
  m = TRY;
  n = DEG;
  p = atof(argc[2]);
  // printf("確率 p = %lf\n", p); 
  // scanf("%lf", &p);

  //----  初期処理
  //srand((unsigned) time(NULL));    // 時間関数による乱数の初期化
  
  //----  全体の反復
  while ( m-- > 0 ) {
    gettimeofday(&tv, NULL);
    srand(tv.tv_sec + tv.tv_usec);
    //--  配列の初期化
    for ( k = 0; k < n; k++ ) {
      arr[k] = k;
    }
    //--  乱順列
    prand(arr, n, p);    // 確率指定

    start = clock();
    //----  整列算法
    switch ( sw ) {
    case 6:
      quick_sort(arr, n, &ct_cmp, &ct_swp);
      break;
    case 7:
      merge_sort(arr, n, &ct_cmp, &ct_swp);
      break;
    case 8:
      heap_sort(arr, n, &ct_cmp, &ct_swp);
      break;
    }
    end = clock();
    
    cmp += ct_cmp;
    swp += ct_swp;
    ct_cmp = 0;
    ct_swp = 0;
    
    t0 += (end - start + 0.0) / CLOCKS_PER_SEC;
  }

  //----  整列結果の出力
  //printf("%s  比較 %3d回  交換 %3d回\n", str, ct_cmp, ct_swp);
  printf("%3d,%3d,", cmp/TRY, swp/TRY);
  printf("%lf\n", t0/TRY);
  
  return 0;
}

//====================================================================
//  クイックソート
//====================================================================

//--------------------------------------------------------------------
//  クイックソートの本体
//--------------------------------------------------------------------

void quick_sort(Data arr[], int n, int *ct_c, int *ct_s) 
{
  //----  クイックソートの再帰処理の呼出
  quick_sort_rec(arr, 0, n-1, n, ct_c, ct_s);
}

//--------------------------------------------------------------------
//  クイックソートの再帰処理(トップダウン)
//--------------------------------------------------------------------

void quick_sort_rec(Data arr[], int low, int hig, 
                    int n, int *ct_c, int *ct_s) 
{
  int i = low;
  int j = hig;
  int k = (low+hig)/2;    // 中央位置
  Data key = arr[k];      // 基準値

  //----  再帰終了
  if ( low  >= hig ) { return; }

  //----  振分処理
  while ( i <= j ) { 
    //----  左側での比較
    while ( arr[i] < key ) {    // 左側で基準値以上の要素
      (*ct_c)++; i++;    
    }    
    (*ct_c)++;    // 最後の比較の分
    //----  右側での比較
    while ( arr[j] > key ) {    // 右側で基準値以下の要素
      (*ct_c)++; j--;    
    }    
    (*ct_c)++;    // 最後の比較の分
    //----  交換
    if ( i > j ) { break; }          // 走査の完了
    arr_swap_ct(arr, i, j, ct_s);    // 要素の交換
    i++; j--;
  }

  //----  再帰呼出
  if ( low < j ) { quick_sort_rec(arr, low, j, n, ct_c, ct_s); }
  if ( hig > i ) { quick_sort_rec(arr, i, hig, n, ct_c, ct_s); }
}

//--------------------------------------------------------------------
//  クイックソートの振分処理
//--------------------------------------------------------------------

void parti_proc(Data arr[], int low, int hig, int key, int *m_l, int *m_h) 
{
  int tmp;
  while ( 1 ) { 
    //----  左右からの比較による交換位置の特定
    while ( arr[low] < key ) { low++; }
    while ( arr[hig] > key ) { hig--; }
    //----  要素交換
    if ( low >= hig ) { break; }
    arr_swap(arr, low, hig);
    low++; hig--;
  }
  *m_l = low; *m_h = hig;
}

//--------------------------------------------------------------------
//  クイックソートの反復処理(スタックによる深優先処理)
//--------------------------------------------------------------------

void quick_sort_it_st(Data arr[], int n) 
{
  int m = 0;
  int *low = (int *) malloc(sizeof(int)*n);    // 部分列の左端を格納するスタック
  int *hig = (int *) malloc(sizeof(int)*n);    // 部分列の右端を格納するスタック
  int l, h;        // 部分列の両端
  int i, j, k;     // 反復変数
  Data key;        // 基準値
  Data tmp;        // 一時値

  //----  スタックの初期化
  low[m] = 0;      // 全体の左端を格納
  hig[m] = n-1;    // 全体の右端を格納
  m++;

  //----  クイックソートの本体
  while ( m > 0 ) {
    //----  部分列の両端をスタックからポップ
    m--;
    l = low[m]; i = l;
    h = hig[m]; j = h;
    k = (i+j) /2;      // 中央位置
    key = arr[k];      // 基準値
    //----  振分処理
    while ( i <= j ) {
      //----  左右からの比較による交換位置の特定
      while ( arr[i] < key ) { i++; }
      while ( arr[j] > key ) { j--; }
      //----  要素交換
      if ( i > j ) { break; }
      arr_swap(arr, i, j);
      i++; j--;
    }
    //----  部分列の両端をスタックにプッシュ
    if ( h > i ) { hig[m] = h; low[m] = i; m++; }
    if ( l < j ) { low[m] = l; hig[m] = j; m++; }
  }
}

//====================================================================
//  マージソート
//====================================================================

//--------------------------------------------------------------------
//  マージソートの本体
//--------------------------------------------------------------------

void merge_sort(Data arr[], int n, int *ct_c, int *ct_s) 
{
  //----  事前処理
  Data *tmp = (Data *) malloc(sizeof(Data) * (n+1)/2);    // 一時配列の確保
  //----  マージソートの再帰処理の呼出
  merge_sort_rec(arr, 0, n-1, tmp, n, ct_c, ct_s);
}

//--------------------------------------------------------------------
//  マージソートの再帰処理(ボトムアップ)
//--------------------------------------------------------------------

void merge_sort_rec(Data arr[], int low, int hig, Data tmp[], 
                    int n, int *ct_c, int *ct_s) {
  //----  局所変数
  int i = 0;
  int j = (low+hig)/2;    // 中央位置
  int k;
  //----  再帰終了
  if ( low >= hig ) { return; }

  //----  再帰呼出
  if ( low < j ) { 
    merge_sort_rec(arr, low, j, tmp, n, ct_c, ct_s);    // 左部分列
  }
  
  j++;
  
  if ( j < hig ) { 
    merge_sort_rec(arr, j, hig, tmp, n, ct_c, ct_s);    // 右部分列
  }
  //----  事前処理
  for ( k = low; k < j; k++ ) { tmp[k-low] = arr[k]; }
  //----  併合処理
  for ( k = low; k < j; k++ ) {
    if ( j > hig ) { 
      arr[k] = tmp[i]; i++; (*ct_s)++;
    } else {
      (*ct_c)++;
      if ( tmp[i] <= arr[j] ) { 
        arr[k] = tmp[i]; i++; (*ct_s)++;
      } else { 
        arr[k] = arr[j]; j++; (*ct_s)++; 
      }
    }
  }
}

//--------------------------------------------------------------------
//  マージソートの反復処理(キューによる幅優先処理)
//--------------------------------------------------------------------

void merge_sort_it_qu(Data arr[], int n) 
{
  //----  局所変数
  int g = 2;    // 部分列の長さ
  int l, h;     // 左右の部分列の先頭
  //----  全体列になるまで
  while ( g < n-1 ) {
    l = 0; h = l+g-1;    // 左部分列よ右部分列の先頭
    while ( h < n ) {
      //----  併合処理の呼出
      merge_proc(arr, l, h);
      //----  左右の部分列の更新
      l += g; h = l+g-1;
    }
    //----  部分列の更新
    g *= 2;
  }
}

//--------------------------------------------------------------------
//  マージソートの併合処理
//--------------------------------------------------------------------

void merge_proc(Data arr[], int l, int h)
{
  //----  局所変数
  int i = l;
  int j = (l+h)/2;
  int k;
  Data *tmp = (Data *) malloc(sizeof(Data)*(l-h));
  //----  事前処理(左部分列の一時配列のコピー)
  for ( k = l; k < j; k++ ) { tmp[k-l] = arr[k]; }
  //----  併合処理
  for ( k = l; k < j; k++ ) {
    if ( j > h || tmp[i] <= arr[j] ) { 
      arr[k] = tmp[i]; i++;    // 左部分列からの要素コピー
    } else { 
      arr[k] = arr[j]; j++;    // 右部分列からの要素コピー
    }
  }
}

//====================================================================
//  ヒープソート
//====================================================================

//--------------------------------------------------------------------
//  ヒープソートの本体
//--------------------------------------------------------------------

void heap_sort(Data arr[], int n, int *ct_c, int *ct_s) 
{
  int k;

  //----  ヒープ木への変換
  for ( k = n/2; k >= 0; k-- ) {
    heap_sort_rec(arr, k, n-1, ct_c, ct_s);    // ヒープ木の篩落し
  }

  //----  ヒープ木からの整列
  for ( k = n-1; k > 0; k-- ) {  
    arr_swap_ct(arr, 0, k, ct_s);              // 最大要素を整列済の部分列に移動
    heap_sort_rec(arr, 0, k-1, ct_c, ct_s);    // ヒープ木の篩落し
  }
}

//--------------------------------------------------------------------
//  ヒープ木の篩落し(再帰法)
//--------------------------------------------------------------------

void heap_sort_rec(Data arr[], int up, int lst, int *ct_c, int *ct_s) 
{
  int ch = 2*up+1;    // 左の子節の位置

  //----  再帰終了
  if ( ch > lst ) { return; }

  //----  子節同士の比較
  if ( ch+1 <= lst ) {                      // 右の子節があるとき
    (*ct_c)++;    // 比較回数のカウント
    if ( arr[ch] < arr[ch+1] ) { ch++; }    // 子節同士の比較
  }

  //----  親節と子節の比較
  (*ct_c)++;    // 比較回数のカウント
  if ( arr[up] < arr[ch] ) {                    // 親節と子節の比較
    arr_swap_ct(arr, up, ch, ct_s);             // 親節と子節の交換
    heap_sort_rec(arr, ch, lst, ct_c, ct_s);    // 子節を根節とする再帰呼出
  }
}

//====================================================================
//  補助関数
//====================================================================

//--------------------------------------------------------------------
//  配列の要素の比較
//--------------------------------------------------------------------

Bool arr_ord(Data arr[], int p1, int p2) 
{
  if ( arr[p1] <= arr[p2] ) { return TRUE; } else { return FALSE; }
}

Bool arr_ord_ct(Data arr[], int p1, int p2, int *ct) 
{
  (*ct)++;    // 比較回数のカウント
  if ( arr[p1] <= arr[p2] ) { return TRUE; } else { return FALSE; }
}

//--------------------------------------------------------------------
//  配列の要素の交換
//--------------------------------------------------------------------

void arr_swap(Data arr[], int p1, int p2) 
{
  Data tmp;
  tmp = arr[p1]; arr[p1] = arr[p2]; arr[p2] = tmp;
}

void arr_swap_ct(Data arr[], int p1, int p2, int *ct) 
{
  Data tmp;
  (*ct)++;     // 交換回数のカウント
  tmp = arr[p1]; arr[p1] = arr[p2]; arr[p2] = tmp;
}

//====================================================================
//  データの入出力
//====================================================================

//--------------------------------------------------------------------
//  配列への入力
//--------------------------------------------------------------------

void input_arr(Data arr[], int n) 
{
  int k;
  for ( k = 0; k < n; k++ ) { scanf("%d", &arr[k]); }
}

//--------------------------------------------------------------------
//  配列からの出力
//--------------------------------------------------------------------

void output_arr(Data arr[], int n) 
{
  int k;
  for ( k = 0; k < n; k++ ) { printf("%2d ", arr[k]); }
}

//--------------------------------------------------------------------
//  処理過程の表示
//--------------------------------------------------------------------

void proc_view(Data arr[], int n, int ct_c, int ct_s) 
{
  printf(" %3d   %3d :  ", ct_c, ct_s);
  output_arr(arr, n); puts("");
}

//--------------------------------------------------------------------
//  0以上1未満の実数値乱数
//--------------------------------------------------------------------

double frand(void) 
{
  return rand() / (RAND_MAX +1.0);    // +1.0 で実数化
}

//--------------------------------------------------------------------
//  n未満の自然数の整数値乱数
//--------------------------------------------------------------------

int irand(int n) 
{ 
  return (int) (n * frand());    // int型への型変換
}


//====================================================================
//  半乱順列の生成
//====================================================================

//--------------------------------------------------------------------
//  回数指定による半乱順列
//--------------------------------------------------------------------

void crand(Data seq[], int n, int c) 
{
  int p1, p2;
  while ( c-- > 0 ) {                // c回だけ交換
    p1 = irand(n); p2 = irand(n); 
    arr_swap(seq, p1, p2);  
  }
}

//--------------------------------------------------------------------
//  回数指定による半乱順列(必ず交換)
//--------------------------------------------------------------------

void crand2(Data seq[], int n, int c) 
{
  int p1, p2;
  while ( c-- > 0 ) {
    p1 = irand(n); 
    do { p2 = irand(n); } while ( p1 == p2 );    // p2はp1と異なる値を選ぶ
    arr_swap(seq, p1, p2);    
  }
}

//--------------------------------------------------------------------
//  確率指定による半乱順列
//--------------------------------------------------------------------

void prand(Data seq[], int n, double p) 
{
  int k, t;
  for ( k = 1; k < n; k++ ) {    
    if ( frand() < p ) {         // 確率p未満のときのみ
      t = irand(k+1);            // k以下の整乱数
      arr_swap(seq, t, k);       // 要素の交換
    }
  }
}
