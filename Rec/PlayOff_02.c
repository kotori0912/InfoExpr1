//================================================================
// 情報環境実験I 再帰法
// 問題3-01
// 15T207 伊藤 拓海
//================================================================

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define  LEN  100            // 試行回数の最大数

//--------------------------------------------------------------------
//  関数宣言
//--------------------------------------------------------------------

// 連勝(連敗)条件 n による試合数 g までのプレーオフにおいて、連勝数(連敗数) r からの勝敗パターン数

int po_fst(int n, int g, int r, int fst); 
int po_fst_ex(int n, int g, int r, int fst);
// void output_arr(int arr[], int n);

int  recnum = 0;    // 再帰回数

//====================================================================
//  本体関数
//====================================================================

int main(int argc, char *argv[]) {
  //----  宣言
  int len;         // 試合数の上限
  int cnd;         // 連勝条件
  int fst;         // 連敗条件
  int s;           // パターンの個数
  clock_t start, end;      // 時間計測

  double t0;    // 時間の格納
  int sec1;  // 引数での選択

  if ( argc < 4 ) {
    puts("引数が足りません");
    puts("第1引数 : 0 -> 非効率 1 -> 効率的");
    puts("第2引数 : 試合数");
    puts("第3引数 : 連勝条件");
    puts("第4引数 : 連敗条件");
    return 0;
  }
  
  sec1 = atoi(argv[1]);    // 非効率か効率か
  
  // printf("試合数 = ?  "); scanf("%d", &len);
  len = atoi(argv[2]);
  cnd = atoi(argv[3]);
  fst = atoi(argv[4]);

  start = clock();    // 時間計測始まり
  //----  列挙の再帰的処理
  if ( sec1 == 0 ) {
    s = po_fst(cnd, len, 0, fst);
  } else if ( sec1 == 1 ) {
    s = po_fst_ex(cnd, len, 0, fst);
  }
  end = clock();    // 時間計測終わり
  
  t0 += (end - start + 0.0) / CLOCKS_PER_SEC;

  //---- 標準出力
  printf("列挙総数 : %d\n", s);
  printf("処理時間 : %f\n", t0);
  printf("再帰回数 : %d\n", recnum);

/*
  //---- CSV吐き出し
  printf("%d,", s);
  printf("%f, ", t0);
  printf("%d, ", recnum);
*/

  return 0;
}


//====================================================================
//  関数定義
//====================================================================

//-------------------------------------------------------------------
// 連敗条件(非効率)
//-------------------------------------------------------------------

int po_fst(int n, int g, int r, int fst) {
  int s = 0;

  recnum++;

  if ( r >= n ) { return 1; }        // 勝利確定                                                                                               
  if ( r <= -fst ) { return 0; }       // 敗北確定                                                                                             
  if ( r <= -n ) { return 0; }       // 敗北確定                                                                                               
  if ( g == 0 ) { return 0; }       // 引分確定                                                                                                
  if ( r >= 0 ) {                           // 連勝更新または連敗開始                                                                          
    s += po_fst(n, g-1, r+1, fst) + po_fst(n, g-1, -1, fst);
  }
  if ( r < 0 ) {                             // 連勝開始または連敗更新                                                                         
    s += po_fst(n, g-1, r+1, fst) + po_fst(n, g-1, r-1, fst);
  }

  return s;
}



//--------------------------------------------------------------------
// 連敗条件(効率)
//--------------------------------------------------------------------

int po_fst_ex(int n, int g, int r, int fst) {
  int s = 0;

  recnum++;

  if ( r >= n ) { return 1; }          // 勝利確定                                                                                             
  if ( r <= -fst ) { return 0; }       // 敗北確定                                                                                             
  if ( r <= -n ) { return 0; }
  if ( g == 0 ) { return 0; }
  if ( r >= 0 && g + r < n ) { return 0; }
  if ( r < 0 && g < n ) { return 0; }
  if ( r >= 0 ) {                        // 連敗開始                                                                                           
    s += po_fst_ex(n, g-1, r+1, fst) + po_fst_ex(n, g-1, -1, fst);
  }
  if ( r < 0 ) {                          // 連敗更新                                                                                          
    s += po_fst_ex(n, g-1, r+1, fst) + po_fst_ex(n, g-1, r-1, fst);
  }

  return s;
}



/*
//--------------------------------------------------------------------
//  配列の出力
//--------------------------------------------------------------------

void output_arr(int arr[], int n) {
  int k;
  printf(" ");
  for ( k = 0; k < n; k++ ) { printf("%+2d  ", arr[k]); }
  puts("");
}
*/
