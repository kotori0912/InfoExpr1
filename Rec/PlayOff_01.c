//================================================================
// 情報環境実験I 再帰法
// 問題3-01
// 15T207 伊藤 拓海
//================================================================

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define  LEN  100            // 試行回数の最大数

//--------------------------------------------------------------------
//  関数宣言
//--------------------------------------------------------------------

// 連勝(連敗)条件 n による試合数 g までのプレーオフにおいて、連勝数(連敗数) r からの勝敗パターン数

int po_cnt(int n, int g, int r);
int po_cnt_ex(int n, int g, int r); 
// void output_arr(int arr[], int n);

int recnum = 0;    // 再帰回数

//====================================================================
//  本体関数
//====================================================================

int main(int argc, char *argv[]) {
  //----  宣言
  int len;         // 試合数の上限
  int cnd;         // 連勝条件
  int s;           // パターンの個数
  clock_t start, end;      // 時間計測

  double t0;    // 時間の格納
  int sec1;  // 引数での選択

  if ( argc < 3 ) {
    puts("引数が足りません");
    puts("第1引数 : 0 -> 非効率 1 -> 効率的");
    puts("第2引数 : 試合数");
    puts("第3引数 : 連勝条件");
    return 0;
  }
  
  sec1 = atoi(argv[1]);    // 非効率か効率か
  
  // printf("試合数 = ?  "); scanf("%d", &len);
  len = atoi(argv[2]);
  cnd = atoi(argv[3]);

  start = clock();    // 時間計測始まり
  //----  列挙の再帰的処理
  if ( sec1 == 0 ) {
    s = po_cnt(cnd, len, 0);
  } else if ( sec1 == 1 ) {
    s = po_cnt_ex(cnd, len, 0);
  }
  end = clock();    // 時間計測終わり
  
  t0 += (end - start + 0.0) / CLOCKS_PER_SEC;

  //----  数え上げ出力
  printf("%d, ", s);
  //----  処理時間出力
  //printf("%f, ", t0);
  //---- 再帰回数
  //printf("%d, ", recnum);
  
  return 0;
}


//====================================================================
//  関数定義
//====================================================================

//--------------------------------------------------------------------
//  連勝条件(非効率)
//--------------------------------------------------------------------

int po_cnt(int n, int g, int r) {
  int s = 0;
  
  recnum++;
    
  if ( r >= n ) { return 1; }        // 勝利確定
  if ( r <= -n ) { return 0; }       // 敗北確定  
  if ( g == 0 ) { return 0; }       // 引分確定 
  if ( r >= 0 ) {                           // 連勝更新または連敗開始
    s += po_cnt(n, g-1, r+1) + po_cnt(n, g-1, -1);
  } 
  if ( r < 0 ) {                             // 連勝開始または連敗更新
    s += po_cnt(n, g-1, +1) + po_cnt(n, g-1, r-1);
  }
    
  return s;
}

//--------------------------------------------------------------------
//  連勝条件(効率)
//--------------------------------------------------------------------

int po_cnt_ex(int n, int g, int r) {
  int s = 0;
  
  recnum++;
    
  if ( r >= n ) { return 1; }
  if ( r <= -n ) { return 0; }  
  if ( g == 0 ) { return 0; }
  if ( r >= 0 && g + r == n ) { return 1; }
  if ( r >= 0 && g + r < n ) { return 0; } 
  if ( r < 0 && g == n ) { return 1; } 
  if ( r < 0 && g < n ) { return 0; }
  if ( r >= 0 ) {
    s += po_cnt_ex(n, g-1, r+1) + po_cnt_ex(n, g-1, -1);
  }
  if ( r < 0 ) {
    s += po_cnt_ex(n, g-1, +1) + po_cnt_ex(n, g-1, r-1);
  }

  return s;
}

/*
//--------------------------------------------------------------------
//  配列の出力
//--------------------------------------------------------------------

void output_arr(int arr[], int n) {
  int k;
  printf(" ");
  for ( k = 0; k < n; k++ ) { printf("%+2d  ", arr[k]); }
  puts("");
}
*/
